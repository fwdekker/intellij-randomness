package com.fwdekker.randomness.testhelpers

import com.fwdekker.randomness.DecoratorScheme
import com.fwdekker.randomness.Icons
import com.fwdekker.randomness.InsertAction
import com.fwdekker.randomness.OverlayIcon
import com.fwdekker.randomness.Scheme
import com.fwdekker.randomness.SchemeEditor
import com.fwdekker.randomness.State
import com.fwdekker.randomness.TypeIcon
import com.fwdekker.randomness.ui.Validator
import com.fwdekker.randomness.ui.ValidatorDsl.Companion.validators
import com.fwdekker.randomness.ui.withName
import com.intellij.openapi.ui.DialogPanel
import com.intellij.ui.dsl.builder.bindText
import com.intellij.ui.dsl.builder.panel
import java.awt.Color
import kotlin.random.Random


/**
 * A simple [State] with a single mutable [list].
 */
data class DummyState(val list: MutableList<Int> = mutableListOf()) : State() {
    override fun deepCopy(retainUuid: Boolean) =
        copy(list = list.toMutableList()).deepCopyTransient(retainUuid)
}

/**
 * A simple [Scheme] named [name] that outputs according to [generator] (which by default outputs [prefix] followed by
 * the number of the generated value), is valid if and only if [valid] is `true`, and uses customizable [decorators].
 */
data class DummyScheme(
    override var name: String = "DummyScheme",
    var valid: Boolean = true,
    var prefix: String = "text",
    var generator: (Int) -> List<String> = { count -> List(count) { "$prefix$it" } },
    override val decorators: List<DecoratorScheme> = emptyList(),
) : Scheme() {
    override var typeIcon: TypeIcon? = TypeIcon(Icons.SCHEME, "dum", listOf(Color.GRAY))
    override val validators = validators { of(::valid).check({ valid }, { "DummyScheme is invalid" }) }


    override fun generateUndecoratedStrings(count: Int) = generator(count)

    override fun deepCopy(retainUuid: Boolean) =
        copy(decorators = decorators.map { it.deepCopy(retainUuid) }).deepCopyTransient(retainUuid)
}

/**
 * A simple [DecoratorScheme] that appends [append] if [enabled] is `true`, is valid if and only if [valid] is `true`,
 * and uses customizable [decorators].
 */
data class DummyDecoratorScheme(
    var enabled: Boolean = false,
    var valid: Boolean = true,
    var append: String = ":decorated",
    override val decorators: List<DecoratorScheme> = emptyList(),
) : DecoratorScheme() {
    override val name = "DummyDecoratorScheme"
    override var overlayIcon: OverlayIcon? = null
    override val isEnabled get() = enabled
    override val validators = validators { of(::valid).check({ valid }, { "DummyDecoratorScheme is invalid" }) }


    override fun generateUndecoratedStrings(count: Int) =
        generator(count).map { "$it$append" }

    override fun deepCopy(retainUuid: Boolean) =
        copy(decorators = decorators.map { it.deepCopy(retainUuid) }).deepCopyTransient(retainUuid)
}

/**
 * A simple [SchemeEditor] that edits [scheme] using the panel constructed by [panel] (instead of having to create a new
 * subclass Ã  la `object : SchemeEditor` each time) and exposes a few methods that are normally protected.
 */
open class DummySchemeEditor(
    scheme: DummyScheme = DummyScheme(),
    panel: DummySchemeEditor.() -> DialogPanel = { panel {} },
) : SchemeEditor<DummyScheme>(scheme) {
    override val rootComponent = panel(this)


    fun addExtraComponent(component: Any) = extraComponents.add(component)

    fun addDecoratorEditor(editor: SchemeEditor<*>) = decoratorEditors.add(editor)
}

/**
 * A simple [SchemeEditor] for a [DummyDecoratorScheme] that edits only the [DummyDecoratorScheme.append] field.
 */
class DummyDecoratorSchemeEditor(
    scheme: DummyDecoratorScheme = DummyDecoratorScheme(),
) : SchemeEditor<DummyDecoratorScheme>(scheme) {
    override val rootComponent: DialogPanel =
        panel {
            row {
                textField()
                    .withName("decoratorText")
                    .bindText(scheme::append)
                    .bindValidation(scheme::append)
            }
        }.finalize(this)


    init {
        reset()
    }
}

/**
 * A simple [InsertAction] that outputs the strings generated by [generator].
 */
class DummyInsertAction(
    repeat: Boolean = false,
    private val generator: (Random) -> String,
) : InsertAction(repeat, "Dummy", null, null) {
    override fun generateStrings(count: Int) = List(count) { generator(Random.Default) }
}


/**
 * A simple [Scheme] that is not very customisable, but is useful for testing validation.
 */
data class DummyValidatableScheme(
    var foo: String = "foo",
    var bar: String = "bar",
) : Scheme() {
    override val name: String = "ExampleScheme"
    override val decorators: List<DecoratorScheme> = emptyList()
    override val validators: List<Validator<*>> = validators {
        of(::foo).check({ it.lowercase() == "foo" }, { "Foo field is invalid." })
        of(::bar).check({ it.lowercase() == "bar" }, { "Bar field is invalid." })
    }


    override fun generateUndecoratedStrings(count: Int): List<String> = List(count) { "String" }

    override fun deepCopy(retainUuid: Boolean): Scheme = copy().deepCopyTransient(retainUuid)
}

/**
 * A simple [SchemeEditor] for [DummyValidatableScheme]s.
 */
class DummyValidatableSchemeEditor(scheme: DummyValidatableScheme) : SchemeEditor<DummyValidatableScheme>(scheme) {
    override val rootComponent = panel {
        row {
            label("Label").withName("label")

            textField()
                .withName("foo")
                .bindText(scheme::foo)
                .bindValidation(scheme::foo)

            textField()
                .withName("bar")
                .bindText(scheme::bar)
                .bindValidation(scheme::bar)
        }
    }.finalize(this).also { it.name = "myRoot" }


    init {
        reset()
    }
}
